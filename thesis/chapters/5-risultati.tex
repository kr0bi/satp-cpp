%!TEX root = ../dissertation.tex

\chapter{Risultati sperimentali}
\label{chp:risultati}

Questo capitolo riporta una prima analisi sperimentale mirata, in linea con la
richiesta del relatore: partire da due grafici elementari ma informativi e
commentarli in modo rigoroso.

L'analisi usa esclusivamente la modalità \emph{streaming} del framework:
\begin{itemize}
    \item grafico 1: numero di campioni processati vs stima media \(\hat{F}_0(t)\), con curva reale \(F_0(t)\);
    \item grafico 2: numero di campioni processati vs varianza della stima.
\end{itemize}

\section{Setup sperimentale del pacchetto risultati}

In questo primo blocco di risultati è stato fissato:
\begin{itemize}
    \item dimensione stream per partizione: \(n=10^7\);
    \item numero di partizioni/esecuzioni: \(p=50\);
    \item seed dataset: \(21041998\);
    \item cardinalità finali: \(F_0 \in \{10^5,10^6,5\cdot10^6,10^7\}\), cioè \(d/n \in \{1\%,10\%,50\%,100\%\}\).
\end{itemize}

Gli algoritmi confrontati in questo pacchetto sono:
\begin{itemize}
    \item HyperLogLog++ (\(k=14\));
    \item HyperLogLog (\(k=14, L=32\));
    \item LogLog (\(k=14, L=32\));
    \item Probabilistic Counting (\(L=31\)).
\end{itemize}

Nel CSV streaming del framework:
\begin{itemize}
    \item l'asse \(x\) dei grafici corrisponde a \codepath{number_of_elements_processed};
    \item la stima media \(\hat{F}_0(t)\) corrisponde a \codepath{f0_heat_mean_t};
    \item il valore reale \(F_0(t)\) corrisponde a \codepath{f0_mean_t};
    \item la dispersione è in \codepath{variance}.
\end{itemize}

I notebook usati per i grafici sono:
\begin{itemize}
    \item \codepath{notebooks/01_streaming_stima_vs_reale.ipynb};
    \item \codepath{notebooks/02_streaming_varianza.ipynb}.
\end{itemize}

Per ciascun grafico sono riportate sia la versione in scala lineare, sia la
versione in scala doppio-logaritmica, per rendere leggibile sia il regime
iniziale (pochi campioni) sia quello finale (campioni grandi).

\section{Grafico 1: campioni vs stima (con reale)}

Il primo grafico confronta, per ogni algoritmo, la curva media \(\hat{F}_0(t)\)
con la curva reale \(F_0(t)\). Questa vista evidenzia:
\begin{itemize}
    \item comportamento nel transitorio iniziale;
    \item convergenza verso l'endpoint;
    \item presenza di sovra/sottostima sistematica.
\end{itemize}

\subsection{Osservazioni qualitative}

Le osservazioni principali sono:
\begin{itemize}
    \item \textbf{HLL++} e \textbf{HLL} sono vicini alla curva reale lungo tutto il flusso, con scostamenti contenuti;
    \item \textbf{LogLog} presenta una forte sovrastima nel tratto iniziale (ordine di migliaia anche quando \(F_0(t)\) è piccolo), poi rientra progressivamente;
    \item \textbf{Probabilistic Counting} con \(L=31\) mostra overshoot marcato e persistente nei casi ad alta cardinalità;
    \item la versione doppio-log rende chiaramente visibile che la differenza tra algoritmi nasce soprattutto ai piccoli \(t\).
\end{itemize}

\subsection{Sintesi endpoint}

La Tabella~\ref{tab:res-endpoint-relerr} riporta l'errore relativo all'endpoint
\(t=n\), definito come
\[
\mathrm{RE}_{\text{end}}=\frac{\left|\hat{F}_0(n)-F_0(n)\right|}{F_0(n)}.
\]

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.15}
    \begin{tabular}{|l|r|r|r|r|}
        \hline
        Algoritmo & \(F_0=10^5\) & \(F_0=10^6\) & \(F_0=5\cdot10^6\) & \(F_0=10^7\) \\
        \hline
        HyperLogLog++ (\(k=14\)) & 0.002862 & 0.000113 & 0.000096 & 0.002633 \\
        HyperLogLog (\(k=14,L=32\)) & 0.002862 & 0.000113 & 0.000096 & 0.002635 \\
        LogLog (\(k=14,L=32\)) & 0.002276 & 0.002356 & 0.002384 & 0.002709 \\
        Probabilistic Counting (\(L=31\)) & 0.139551 & 0.565726 & 0.355608 & 1.168972 \\
        \hline
    \end{tabular}
    \caption{Errore relativo all'endpoint in modalità streaming (\(n=10^7\), \(p=50\), seed 21041998).}
    \label{tab:res-endpoint-relerr}
\end{table}

Interpretazione:
\begin{itemize}
    \item HLL++ e HLL sono praticamente coincidenti all'endpoint in questo setup;
    \item LogLog è accurato all'endpoint, ma meno stabile nel transitorio;
    \item PC risulta sistematicamente meno accurato, con errore molto alto soprattutto per \(F_0\) grandi.
\end{itemize}

\section{Grafico 2: campioni vs varianza}

Il secondo grafico mostra l'evoluzione di \(\mathrm{Var}[\hat{F}_0(t)]\) al
crescere dei campioni processati.

\subsection{Osservazioni qualitative}

Dal confronto emerge che:
\begin{itemize}
    \item HLL++ e HLL hanno varianza molto simile e contenuta rispetto a PC;
    \item LogLog ha varianza moderata in valore assoluto, ma peggiora nel transitorio perché la stima è fortemente biased all'inizio;
    \item PC mostra un'esplosione di varianza per cardinalità medie/alte.
\end{itemize}

La scala doppio-logaritmica è essenziale in questo grafico: in scala lineare la
curva di PC tende a dominare e rende poco leggibili le differenze tra HLL, HLL++
e LogLog.

\subsection{Sintesi numerica}

La Tabella~\ref{tab:res-endpoint-var} riporta la varianza all'endpoint \(t=n\).

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.15}
    \begin{tabular}{|l|r|r|r|r|}
        \hline
        Algoritmo & \(F_0=10^5\) & \(F_0=10^6\) & \(F_0=5\cdot10^6\) & \(F_0=10^7\) \\
        \hline
        HyperLogLog++ (\(k=14\)) & \(5.486\cdot10^5\) & \(1.083\cdot10^8\) & \(1.327\cdot10^9\) & 0 \\
        HyperLogLog (\(k=14,L=32\)) & \(5.486\cdot10^5\) & \(1.083\cdot10^8\) & \(1.327\cdot10^9\) & 0 \\
        LogLog (\(k=14,L=32\)) & \(1.058\cdot10^6\) & \(1.518\cdot10^8\) & \(1.288\cdot10^9\) & 0 \\
        Probabilistic Counting (\(L=31\)) & \(4.704\cdot10^9\) & \(1.438\cdot10^{12}\) & \(4.118\cdot10^{13}\) & 0 \\
        \hline
    \end{tabular}
    \caption{Varianza all'endpoint in modalità streaming (\(n=10^7\), \(p=50\), seed 21041998).}
    \label{tab:res-endpoint-var}
\end{table}

Il valore 0 all'endpoint per \(F_0=10^7\) indica che, in questo specifico setup,
le 50 esecuzioni convergono allo stesso valore finale per ciascun algoritmo;
non implica assenza generale di variabilità.

\section{Confronto sintetico HLL vs HLL++ nel transitorio}

Poiché all'endpoint HLL e HLL++ sono quasi indistinguibili, la differenza si
osserva meglio sulle curve complete. La Tabella~\ref{tab:res-hll-hllpp-curve}
riporta la media della MRE lungo i checkpoint:
\[
\overline{\mathrm{MRE}}_{\text{curve}}=
\frac{1}{K}\sum_{i=1}^{K}\mathrm{MRE}(t_i).
\]

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.15}
    \begin{tabular}{|r|r|r|r|}
        \hline
        \(F_0\) & \(\overline{\mathrm{MRE}}_{\text{curve}}\) HLL & \(\overline{\mathrm{MRE}}_{\text{curve}}\) HLL++ & miglioramento HLL++ \\
        \hline
        \(10^5\) & 0.005587 & 0.002392 & 57.18\% \\
        \(10^6\) & 0.005900 & 0.002761 & 53.21\% \\
        \(5\cdot10^6\) & 0.005581 & 0.002589 & 53.60\% \\
        \(10^7\) & 0.005281 & 0.002355 & 55.41\% \\
        \hline
    \end{tabular}
    \caption{Confronto HLL vs HLL++ sulla MRE media lungo il flusso (\(n=10^7\), \(p=50\), seed 21041998).}
    \label{tab:res-hll-hllpp-curve}
\end{table}

Questa tabella mostra che, pur avendo endpoint quasi identici, HLL++ mantiene
un errore medio lungo la curva sistematicamente più basso di HLL.

\section{Conclusioni della prima analisi}

Per il pacchetto richiesto dal relatore, i due grafici base producono una prima
evidenza chiara:
\begin{enumerate}
    \item HLL++ e HLL sono entrambi accurati all'endpoint nel setup considerato;
    \item HLL++ è migliore nel transitorio (errore medio lungo il flusso circa
    dimezzato rispetto a HLL);
    \item LogLog è penalizzato soprattutto nei piccoli campioni;
    \item Probabilistic Counting (\(L=31\)) mostra varianza elevata e bias marcato
    sui regimi di cardinalità medio-alti.
\end{enumerate}

Questi risultati sono sufficienti come base per il confronto iniziale; la fase
successiva estenderà l'analisi a più seed e a sweep più ampi dei parametri per
valutare la robustezza statistica delle conclusioni.
