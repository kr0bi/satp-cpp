%!TEX root = ../dissertation.tex

\chapter{Risultati sperimentali}
\label{chp:risultati}

In questo capitolo presenta i risultati sperimentali finali ottenuti con il
framework descritto nel Capitolo~\ref{chp:implementazione}.
L'analisi è limitata alle modalità di \emph{streaming} e di \emph{merge}, mentre i
file \emph{oneshot} non vengono utilizzati poiché, a differenza, della modalità streaming viene preso un solo risultato finale per esecuzione.
Le metriche considerate sono quelle formalizzate nel
Capitolo~\ref{chp:background}.

\section{Ambiente di test}
I risultati sperimentali sono stati ottenuti su un notebook Apple MacBook Pro 13'' (2020) con processore Apple M1
(Apple Silicon) con 16 GB di memoria RAM, un SSD NVMe da 512 GB e macOS Sequoia 15.7.2.

L'esecuzione è avvenuta localmente su singola macchina, senza distribuzione su più nodi.

La build e l'esecuzione dei test sono state effettuate con la seguente toolchain:
\begin{itemize}
    \item CMake 4.2.3;
    \item Apple Clang 17.0.0 (\texttt{clang-1700.0.13.5});
    \item target compilazione: \texttt{arm64-apple-darwin24.6.0}.
\end{itemize}

\subsection{Configurazione sperimentale}
I risultati sono stati estratti dai CSV presenti in \codepath{results/} con la
seguente configurazione:
\begin{itemize}
    \item \(n=10^7\) elementi per partizione;
    \item \(F_0 \in \{10^5,10^6,5\cdot10^6,10^7\}\);
    \item seed \(\in \{42,137357,10032018,21041998,29042026\}\);
    \item 50 run per ogni dataset.
\end{itemize}

Ottenendo un totale di 72 file di \codepath{results\_streaming.csv} e \codepath{results\_merge.csv}.

La produzione delle figure e delle tabelle è stata ottenuta tramite l'utilizzo di notebook Jupyter per
riproducibilità all'interno della cartella \texttt{notebooks}.

\section{Selezione delle configurazioni migliori}
Uno dei principali problemi di tutte queste possibili configurazioni dei parametri per ogni algoritmo è stato di
individuare quali fossero i parametri ottimali.

Il confronto principale è avvenuto fissando, per ciascun algoritmo, il parametro
che minimizza il \emph{mean relative error} medio al checkpoint finale
(aggregazione su seed e valori di \(F_0\)).
I parametri individuati sono riportati nella tabella \ref{tab:best-config-selection}.

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.12}
    \begin{tabular}{|l|c|r|}
        \hline
        Algoritmo & Parametro migliore & MRE medio endpoint \\
        \hline
        HyperLogLog & \(k=16\) & 0.002736 \\
        \hline
        HyperLogLog++ & \(k=18\) & 0.001370 \\
        \hline
        LogLog & \(k=15\) & 0.005615 \\
        \hline
        Probabilistic Counting & \(L=23\) & 0.524951 \\
        \hline
    \end{tabular}
    \caption{Configurazione migliore per algoritmo nel dominio esplorato.}
    \label{tab:best-config-selection}
\end{table}

\section{Confronto tra i vari seed}
Per poter fare le analisi successive si è fatta prima un'analisi sperimentale per verificare
che scegliere un seed rispetto ad un altro non cambi le valutazioni degli algoritmi in maniera gravosa.

L'analisi è stata eseguita fissando, per ciascun algoritmo, la configurazione
migliore della Tabella~\ref{tab:best-config-selection} e confrontando i seed
\(\{42,137357,10032018,21041998,29042026\}\) sui valori finali di
\texttt{results\_streaming.csv}.
Per misurare la sensibilità al seed è stato utilizzato il coefficiente di
variazione
\[
\mathrm{CV}(X)=\frac{\sigma(X)}{|\mathbb{E}[X]|},
\]
calcolato su MRE, RMSE, varianza e bias.

Il CV è una misura \emph{adimensionale} di dispersione relativa: valori vicini
allo \(0\) indicano che la metrica varia poco al variare del seed, mentre valori
più alti indicano maggiore sensibilità.
In seguito si usa la seguente lettura operativa:
\(\mathrm{CV}<0.10\) indica una variabilità contenuta, \(0.10\le\mathrm{CV}<0.20\) una
variabilità moderata, mentre \(\mathrm{CV}\ge 0.20\) una variabilità elevata.

Queste soglie sono interpretative (non universali) e vanno sempre lette insieme
al livello assoluto dell'errore: una configurazione può avere CV basso ma avere un
errore medio alto.

Inoltre, quando \(|\mathbb{E}[X]|\) è molto vicino a zero, il CV può
diventare numericamente instabile; in questi casi la valutazione è supportata
anche da boxplot e metriche assolute.

La Figura~\ref{fig:seed-sens-cv} mostra i valori di CV per configurazione
algoritmica, mentre la Figura~\ref{fig:seed-sens-box} riporta la distribuzione
della MRE sui seed per le configurazioni selezionate.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.88\textwidth]{figures/results/seed_sensitivity_mre_cv_by_setting.png}
    \caption{Sensibilità al seed: coefficiente di variazione della MRE per setting algoritmico.}
    \label{fig:seed-sens-cv}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.88\textwidth]{figures/results/seed_sensitivity_mre_boxplot_best_setting.png}
    \caption{Distribuzione della MRE sui seed nelle configurazioni best-config.}
    \label{fig:seed-sens-box}
\end{figure}

La Tabella~\ref{tab:seed-sens-summary} sintetizza i risultati principali.
HyperLogLog e HyperLogLog++ mostrano una sensibilità simile e contenuta
(\(\mathrm{CV}_{\mathrm{MRE}}\approx 0.079\)); LogLog è leggermente più
sensibile (\(\approx 0.116\)).
Mentre Probabilistic Counting presenta un \(\mathrm{CV}_{\mathrm{MRE}}\) molto basso,
ma con MRE assoluta elevata (circa \(0.5\) nel best-config), ricordando che ``stabile'' non implica ``accurato''.

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{|l|c|c|}
        \hline
        Algoritmo & Parametri (seed-sensitivity) & \(\mathrm{CV}_{\mathrm{MRE}}\) \\
        \hline
        HyperLogLog & \(k=7,\ L=32\) & 0.079052 \\
        \hline
        HyperLogLog++ & \(k=7\) & 0.079061 \\
        \hline
        LogLog & \(k=8,\ L=32\) & 0.116134 \\
        \hline
        Probabilistic Counting & \(L=1\) & \(8.53\times 10^{-6}\) \\
        \hline
    \end{tabular}
    \caption{Sintesi della sensibilità al seed (metrica: coefficiente di variazione della MRE).}
    \label{tab:seed-sens-summary}
\end{table}

In base a questo confronto, i seed scelti non alterano in modo sostanziale la stima
qualitativa tra gli algoritmi nelle configurazioni selezionate.
Di conseguenza, le analisi successive possono essere discusse su un unico seed
rappresentativo, in questo caso si è scelto 21041998, senza perdita di generalità operativa, mantenendo
comunque i risultati aggregati sui seed nelle tabelle riepilogative.

\section{Risultati streaming con le configurazioni ottimali}
Una volta individuati i parametri che minimizzassero il \emph{mean relative error} si è fatta un'analisi
sulla stima media di $F_0$ tra i vari algoritmi utilizzando un unico seed.
\subsection{Stima media nel tempo e transitorio iniziale}
Le figure~\ref{fig:best-stream-est-linear} e
\ref{fig:best-stream-est-loglog} mostrano l'andamento di
\(\hat{F}_0(t)\) rispetto a \(F_0(t)\) con seed 21041998. La scala log-log è usata per rendere visibile il comportamento sui primi
checkpoint.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/best_stream_estimate_vs_truth_linear_seed21041998.png}
    \caption{Best-config: confronto tra stima media \(\hat{F}_0(t)\) e valore reale \(F_0(t)\) in scala lineare (seed 21041998).}
    \label{fig:best-stream-est-linear}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/best_stream_estimate_vs_truth_loglog_seed21041998.png}
    \caption{Stesso confronto della Figura~\ref{fig:best-stream-est-linear} in scala log-log.}
    \label{fig:best-stream-est-loglog}
\end{figure}

In questa configurazione HyperLogLog++ e HyperLogLog seguono da vicino la curva
reale su tutti i livelli di cardinalità testati.
L'algoritmo LogLog rimane comunque vicino ai due algoritmi HLL per \(F_0\) medio-alti, ma mantiene
uno scarto più evidente nel caso \(F_0=10^5\).
Mentre Probabilistic Counting resta l'algoritmo meno stabile nella fase transitoria,
con deviazioni significative già a metà stream.

\subsection{Varianza nel tempo}

La figura~\ref{fig:best-stream-var-loglog} confronta la varianza della stima in
scala log-log.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/best_stream_variance_loglog_seed21041998.png}
    \caption{Best-config: varianza della stima in modalità streaming (seed 21041998, scala log-log).}
    \label{fig:best-stream-var-loglog}
\end{figure}

La dispersione di HyperLogLog++ è inferiore a HyperLogLog e LogLog per quasi
l'intero dominio osservato, in coerenza con la progettazione di HLL++
\cite{Heule_Nunkesser_Hall_2013}.
Per \(F_0=10^7\) la varianza endpoint è nulla per tutte le configurazioni
best-config perché nel dataset usato vale \(n=d\) e l'endpoint è deterministico
tra run.

\subsection{Metriche endpoint aggregate}

La Tabella~\ref{tab:best-stream-summary} riporta le metriche endpoint mediate
sui seed per ciascun valore finale di \(F_0\).

\begin{table}[htbp]
    \centering
    \scriptsize
    \setlength{\tabcolsep}{4pt}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{|l|r|r|r|r|r|}
        \hline
        Algoritmo & \(F_0\) & MRE medio & RMSE medio & Varianza media & \(\hat{F}_0\) medio \\
        \hline
        HyperLogLog++ & 100000 & 0.001237 & 153.661 & 22550.603 & 99990.816 \\
        HyperLogLog++ & 1000000 & 0.001629 & 2026.870 & 3272587.016 & 1000904.100 \\
        HyperLogLog++ & 5000000 & 0.001287 & 8072.642 & 62887388.036 & 5001168.396 \\
        HyperLogLog++ & 10000000 & 0.001326 & 13256.000 & 0.000 & 10013256.000 \\
        \hline
        HyperLogLog & 100000 & 0.002836 & 358.238 & 127585.802 & 100008.844 \\
        HyperLogLog & 1000000 & 0.003195 & 3938.423 & 15118314.694 & 999213.888 \\
        HyperLogLog & 5000000 & 0.002800 & 17416.878 & 278970064.540 & 4994349.692 \\
        HyperLogLog & 10000000 & 0.002113 & 21134.000 & 0.000 & 9978866.000 \\
        \hline
        LogLog & 100000 & 0.005206 & 649.431 & 407725.504 & 100124.060 \\
        LogLog & 1000000 & 0.005390 & 6789.407 & 46105629.058 & 999245.028 \\
        LogLog & 5000000 & 0.004713 & 28669.821 & 699006423.800 & 4988366.864 \\
        LogLog & 10000000 & 0.007150 & 71500.000 & 0.000 & 9928500.000 \\
        \hline
        Probabilistic Counting & 100000 & 0.579277 & 79492.780 & 6139769255.600 & 117344.080 \\
        Probabilistic Counting & 1000000 & 0.911951 & 1321697.966 & 1418662093360.000 & 1646384.880 \\
        Probabilistic Counting & 5000000 & 0.524089 & 3231428.510 & 10582138707400.000 & 5210955.228 \\
        Probabilistic Counting & 10000000 & 0.084486 & 844860.000 & 0.000 & 10844860.000 \\
        \hline
    \end{tabular}
    \caption{Best-config: metriche endpoint aggregate in modalità streaming (media sui seed).}
    \label{tab:best-stream-summary}
\end{table}

La Figura~\ref{fig:best-stream-mre-by-f0} visualizza lo stesso confronto sul
solo MRE endpoint.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.90\textwidth]{figures/results/best_stream_final_mre_by_algorithm_and_f0.png}
    \caption{Best-config: MRE endpoint per algoritmo e valore finale di \(F_0\) (media sui seed).}
    \label{fig:best-stream-mre-by-f0}
\end{figure}


\section{Risultati merge con best-config}

Per ogni algoritmo si confrontano stima da merge e stima seriale su coppie di
partizioni.
Le Figure~\ref{fig:best-merge-box} e \ref{fig:best-merge-nonzero} e la
Tabella~\ref{tab:best-merge-summary} mostrano che nel dominio sperimentale
analizzato i delta sono nulli in tutti i casi.
Il risultato è coerente con gli operatori di merge implementati
(massimo componente-per-componente per LogLog/HLL/HLL++ e OR bit-a-bit per
Probabilistic Counting), discussi in
Capitolo~\ref{chp:implementazione} e nel background sulla mergeabilità.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.76\textwidth]{figures/results/best_merge_delta_abs_by_algorithm.png}
    \caption{Best-config: distribuzione di \codepath{delta\_merge\_serial\_abs}.}
    \label{fig:best-merge-box}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.76\textwidth]{figures/results/best_merge_nonzero_delta_counts.png}
    \caption{Best-config: conteggio dei casi con delta non nullo nel confronto merge vs seriale.}
    \label{fig:best-merge-nonzero}
\end{figure}

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.12}
    \begin{tabular}{|l|r|r|r|r|r|}
        \hline
        Algoritmo & Righe & Media \(\Delta_{abs}\) & Max \(\Delta_{abs}\) & Media \(\Delta_{rel}\) & Max \(\Delta_{rel}\) \\
        \hline
        HyperLogLog & 500 & 0 & 0 & 0 & 0 \\
        \hline
        HyperLogLog++ & 500 & 0 & 0 & 0 & 0 \\
        \hline
        LogLog & 500 & 0 & 0 & 0 & 0 \\
        \hline
        Probabilistic Counting & 500 & 0 & 0 & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Best-config: confronto merge vs seriale. Tutti i delta risultano nulli nel dataset analizzato.}
    \label{tab:best-merge-summary}
\end{table}

\section{Discussione}

Nel dominio sperimentale considerato emergono tre risultati principali.
Primo, HyperLogLog++ risulta il metodo più accurato e stabile tra le
configurazioni migliori, con errore medio endpoint inferiore a HyperLogLog e
LogLog su tutti i livelli di \(F_0\) osservati.
Secondo, LogLog resta competitivo ma con una dispersione più alta e una
sensibilità maggiore nelle cardinalità più piccole.
Terzo, Probabilistic Counting rimane sensibilmente più instabile, anche quando
si seleziona il miglior parametro nel dominio testato.

Per la modalità merge, i risultati sono coerenti con la proprietà di fusione
attesa per gli sketch implementati: nel confronto a coppie non si osservano
scarti rispetto al processamento seriale.

\section{Limiti sperimentali}

I limiti principali della campagna corrente sono:
\begin{itemize}
    \item un solo valore di \(n\) nella fase finale (\(10^7\));
    \item un unico profilo dati (distribuzione uniforme, ordine shuffled);
    \item assenza in questo capitolo di misure esplicite di costo temporale e
    footprint di memoria a runtime.
\end{itemize}

Un'estensione naturale è replicare la stessa analisi su distribuzioni non
uniformi e su workload con overlap controllato tra partizioni, mantenendo il
medesimo protocollo di confronto tra endpoint, transitorio e merge.
