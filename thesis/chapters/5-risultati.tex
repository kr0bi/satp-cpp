%!TEX root = ../dissertation.tex

\chapter{Risultati sperimentali}
\label{chp:risultati}

Questo capitolo riporta l'analisi dei risultati sperimentali prodotti dal framework.
In questa fase vengono considerati esclusivamente i risultati in modalità
\emph{streaming} e \emph{merge}; i file \emph{oneshot} non sono inclusi
nell'analisi.
Le metriche usate sono quelle definite nel Capitolo~\ref{chp:background}.

\section{Perimetro sperimentale e artefatti}

L'analisi è costruita a partire dai CSV presenti nella cartella
\codepath{results/}, con la seguente copertura:
\begin{itemize}
    \item 72 file \codepath{results\_streaming.csv} (totale 288000 righe);
    \item 72 file \codepath{results\_merge.csv} (totale 36000 righe);
    \item \(n = 10^7\) elementi per partizione;
    \item \(F_0 \in \{10^5,10^6,5\cdot 10^6,10^7\}\);
    \item seed \(\{42,137357,10032018,21041998,29042026\}\);
    \item 50 run per configurazione.
\end{itemize}

I notebook usati per produrre grafici e tabelle sono:
\begin{itemize}
    \item \codepath{notebooks/10\_ch5\_streaming\_analysis.ipynb};
    \item \codepath{notebooks/11\_ch5\_merge\_analysis.ipynb}.
\end{itemize}

Entrambi i notebook salvano le figure in
\codepath{thesis/figures/results/} e le tabelle di supporto in
\codepath{notes/}.

\section{Risultati in modalità streaming}

\subsection{Stima media nel tempo: confronto con il valore reale}

Per un confronto diretto tra algoritmi è stata fissata una configurazione di
riferimento coerente con quella usata nel framework CLI:
\begin{itemize}
    \item HyperLogLog++: \(k=16\);
    \item HyperLogLog: \(k=16, L=32\);
    \item LogLog: \(k=16, L=32\);
    \item Probabilistic Counting: \(L=16\).
\end{itemize}

Le Figure~\ref{fig:stream-est-vs-real-linear} e
\ref{fig:stream-est-vs-real-loglog} mostrano
\(\hat{F}_0(t)\) e \(F_0(t)\) sul seed 21041998.
La versione log-log è stata inclusa esplicitamente per evidenziare il
transitorio iniziale, come richiesto dal relatore.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/stream_estimate_vs_truth_linear_seed21041998_ref.png}
    \caption{Modalità streaming: confronto tra stima media \(\hat{F}_0(t)\) e valore reale \(F_0(t)\) in scala lineare (seed 21041998, parametri di riferimento).}
    \label{fig:stream-est-vs-real-linear}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/stream_estimate_vs_truth_loglog_seed21041998_ref.png}
    \caption{Stesso confronto della Figura~\ref{fig:stream-est-vs-real-linear} in scala log-log.}
    \label{fig:stream-est-vs-real-loglog}
\end{figure}

Dalle curve si osserva che HyperLogLog e HyperLogLog++ restano vicini alla
curva reale su tutti i valori di \(F_0\) considerati.
LogLog mostra un errore più marcato nel caso \(F_0=10^5\), mentre
Probabilistic Counting con \(L=16\) sottostima in modo sistematico già a metà
stream e degrada fortemente per cardinalità elevate.

\subsection{Varianza della stima nel tempo}

La Figura~\ref{fig:stream-variance-loglog} riporta la varianza al variare dei
campioni processati (scala log-log).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/stream_variance_loglog_seed21041998_ref.png}
    \caption{Varianza della stima in modalità streaming (seed 21041998, parametri di riferimento, scala log-log).}
    \label{fig:stream-variance-loglog}
\end{figure}

Per HyperLogLog e HyperLogLog++ la dispersione rimane contenuta e con ordine di
grandezza coerente con il comportamento atteso degli sketch a registri
\cite{Flajolet_Fusy_Gandouet_Meunier_2007,Heule_Nunkesser_Hall_2013}.
Nel caso \(F_0=10^7\) la varianza finale risulta nulla per tutte le
configurazioni di riferimento: nel dataset analizzato ogni partizione contiene
\(n=d\), quindi la stima endpoint risulta identica tra run.

\subsection{Metriche finali aggregate e sensibilità ai parametri}

La Tabella~\ref{tab:stream-final-reference-summary} riporta, al checkpoint
finale \(t=n\), le metriche aggregate sui cinque seed per la configurazione di
riferimento.

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.12}
    \begin{tabular}{|l|l|r|r|r|}
        \hline
        Algoritmo & Parametri & MRE medio & RMSE medio & Varianza media \\
        \hline
        HyperLogLog & \(k=16, L=32\) & 0.002736 & 10711.885 & 73553991.259 \\
        \hline
        HyperLogLog++ & \(k=16\) & 0.002905 & 10713.932 & 73557119.220 \\
        \hline
        LogLog & \(k=16, L=32\) & 0.011063 & 14962.369 & 90443926.423 \\
        \hline
        Probabilistic Counting & \(L=16\) & 0.787552 & 3944600.703 & 98644414.550 \\
        \hline
    \end{tabular}
    \caption{Riassunto endpoint in modalità streaming per i parametri di riferimento (media su seed e valori di \(F_0\)).}
    \label{tab:stream-final-reference-summary}
\end{table}

La Figura~\ref{fig:stream-final-mre-by-f0} dettaglia il MRE endpoint per
algoritmo e cardinalità finale.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.90\textwidth]{figures/results/stream_final_mre_by_algorithm_and_f0_ref.png}
    \caption{MRE al checkpoint finale per algoritmo e valore finale di \(F_0\), media sui seed.}
    \label{fig:stream-final-mre-by-f0}
\end{figure}

La sensibilità ai parametri (Figura~\ref{fig:stream-param-sensitivity}) mostra
un comportamento coerente con la teoria:
all'aumentare del numero di registri (parametro \(k\)) diminuisce l'errore
per HLL/HLL++, mentre per PC la scelta di \(L\) riduce solo parzialmente
l'errore nel dominio testato.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.94\textwidth]{figures/results/stream_parameter_sensitivity_final_mre.png}
    \caption{Sensibilità ai parametri: MRE medio al checkpoint finale (media su seed e \(F_0\)).}
    \label{fig:stream-param-sensitivity}
\end{figure}

Le migliori configurazioni osservate nel dominio sperimentale sono riportate in
Tabella~\ref{tab:stream-best-params}.

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.12}
    \begin{tabular}{|l|c|r|}
        \hline
        Algoritmo & Parametro migliore & MRE medio endpoint \\
        \hline
        HyperLogLog & \(k=16\) & 0.002736 \\
        \hline
        HyperLogLog++ & \(k=18\) & 0.001370 \\
        \hline
        LogLog & \(k=15\) & 0.005615 \\
        \hline
        Probabilistic Counting & \(L=23\) & 0.524951 \\
        \hline
    \end{tabular}
    \caption{Miglior parametro per algoritmo nel dominio esplorato (criterio: MRE medio endpoint).}
    \label{tab:stream-best-params}
\end{table}

\subsection{Confronto diretto HyperLogLog vs HyperLogLog++}

La Figura~\ref{fig:stream-hll-hllpp-diff} mostra
\(\lvert\hat{F}_{0,\mathrm{HLL++}}(t)-\hat{F}_{0,\mathrm{HLL}}(t)\rvert\)
per \(k=16\), seed 21041998.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.96\textwidth]{figures/results/stream_hll_vs_hllpp_absdiff_seed21041998.png}
    \caption{Differenza assoluta tra HLL++ e HLL nel tempo (\(k=16\), seed 21041998).}
    \label{fig:stream-hll-hllpp-diff}
\end{figure}

Sul checkpoint finale, aggregando tutti i seed e tutti i valori di \(F_0\), la
media di \(\lvert\Delta\hat{F}_0\rvert\) tra HLL++ e HLL vale 15.714,
con massimo 71.74.
La differenza su MRE resta contenuta: media 0.0001694, massimo 0.0008462.
Ne consegue che, nel dominio testato, i due algoritmi hanno andamento molto
simile a parità di \(k\), pur non essendo identici punto per punto.

\section{Risultati in modalità merge}

L'analisi merge confronta, per ogni coppia di partizioni,
la stima ottenuta con fusione di due sketch e la stima ottenuta con
processamento seriale della stessa coppia.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.78\textwidth]{figures/results/merge_delta_abs_by_algorithm.png}
    \caption{Distribuzione di \codepath{delta\_merge\_serial\_abs} per algoritmo.}
    \label{fig:merge-delta-abs-box}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.78\textwidth]{figures/results/merge_nonzero_delta_counts.png}
    \caption{Conteggio dei casi con delta non nullo nel confronto merge vs seriale.}
    \label{fig:merge-delta-nonzero}
\end{figure}

La Tabella~\ref{tab:merge-summary} sintetizza i risultati su tutti i file merge.

\begin{table}[htbp]
    \centering
    \small
    \setlength{\tabcolsep}{6pt}
    \renewcommand{\arraystretch}{1.12}
    \begin{tabular}{|l|r|r|r|r|r|}
        \hline
        Algoritmo & Righe & Media \(\Delta_{abs}\) & Max \(\Delta_{abs}\) & Media \(\Delta_{rel}\) & Max \(\Delta_{rel}\) \\
        \hline
        HyperLogLog & 6500 & 0 & 0 & 0 & 0 \\
        \hline
        HyperLogLog++ & 7500 & 0 & 0 & 0 & 0 \\
        \hline
        LogLog & 6500 & 0 & 0 & 0 & 0 \\
        \hline
        Probabilistic Counting & 15500 & 0 & 0 & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Confronto merge vs seriale: tutte le metriche di delta risultano nulle nel dataset analizzato.}
    \label{tab:merge-summary}
\end{table}

Nel dominio sperimentale corrente, la fusione di due sketch produce la stessa
stima del processamento seriale della coppia per tutti gli algoritmi e tutte le
configurazioni testate.

\section{Discussione e limiti}

I dati mostrano un quadro netto:
\begin{itemize}
    \item HLL e HLL++ sono i metodi più stabili e accurati tra quelli testati;
    \item LogLog è competitivo su cardinalità medio-alte, ma peggiora nel caso
    \(F_0=10^5\);
    \item Probabilistic Counting, nella forma implementata e con i parametri
    esplorati, non mantiene un errore comparabile agli sketch a registri;
    \item in modalità merge non emergono discrepanze rispetto al seriale.
\end{itemize}

Questi risultati vanno letti con i seguenti limiti:
\begin{itemize}
    \item un solo valore di \(n\) (\(10^7\)) nella campagna finale;
    \item distribuzione dati uniforme e ordine shuffled, senza altri profili
    di workload;
    \item assenza, in questo capitolo, di misure di costo computazionale
    (tempo update/query/merge) e footprint in memoria reale.
\end{itemize}

Nel seguito, l'estensione naturale è ripetere la stessa pipeline su dataset con
strutture di frequenza diverse e confrontare anche i costi temporali/spaziali,
così da affiancare alla qualità della stima una valutazione completa del costo
operativo.
